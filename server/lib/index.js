/*!
 * entrance
 *
 * 폴리곤 메인넷 테스트 결과 최적의 견적 받기(보내는 토큰 & 받는 토큰 각각 입력)와 swap 기능은 정상적으로 작동합니다.
 *
 * 과제를 하면서 제 스스로에게 아쉬웠던 점이 있습니다.
 * 라이브러리를 불러와서
 * new 키워드를 사용하여 새로운 객체를 생성하면서 동시에 constructor 에 wallet address, private key, rpc_url 등이 입력되도록 하면서
 * 사용하는 메서드는 proto 타입을 사용하여 등록하는 방식으로 구현하려 하였으나, 계속 오류가 발생하며 디버깅에 실패하였습니다.
 * 또한 기능에 따라 파일을 세분화하긴 하였으나 디자인 패턴에 대한 짧은 지식으로 작업을 하다보니 깊은 이해를 하지 못하였습니다.
 * 이 부분은 추후 javascript 의 proto 관련 문법이나 "Node.js 디자인 패턴 바이블" 학습을 통해 역량을 빠른 시간 내에 키워나가도록 하곘습니다. 
 
 *** 과제 요구 사항 ***
 1. Swap 의 견적을 얻는 기능 (판매할 수량과 구매할 수량을 각각 고정할 수 있어야 하며, 예상되는 수수료가 포함되어야 한다.)
    - 보내고 받는 두 토큰의 세부 정보와 수량, 최적으로 선택된 swap 프로토콜 정보 및 예상 가스비는
      모두 마지막 res.json() 객체에 담겨 있습니다.
    - 받는 토큰의 수량을 고정했을 때 역견적을 받는 것은 swap 프로토콜마다 AMM 의 차이가 있고,
      AMM과 수수료 계산 방법에 의해 교환되는 토큰의 수량이 일정 비율로 변하는 것이 아니기 때문에
      모든 swap 프로토콜에 공통적으로 적용할 수 있는 범용적 공식은 존재하지 않습니다.
      따라서 보내는 수량을 조절하여 받는 토큰의 갯수가 나올 때까지 api 요청을 반복하여 보내되,
      최소의 요청 횟수로 원하는 값을 얻도록 최적화시키는 방법을 사용하기로 하였습니다.
      => 이분탐색 알고리즘의 변형
         1) 보내는 수량을 임의로 설정하여 받는 토큰 수량을 얻는다.
         2) 보내는 수량과 받는 수량의 대략적인 비율대로 받는 토큰의 고정수량과 맞는 보내는 토큰 수량을 재설정한다.
         3) 재설정한 토큰으로 견적을 받아 받는 수량을 체크한다.
         4) 받는 수량이 원하는(고정된) 수량보다 적으면 일정 단위 g 만큼 보내는 수량을 증가시키고 g를 1/2로 줄인다.
         5) 받는 수량이 원하는(고정된) 수량보다 많으면 일정 단위 g 만큼 보내는 수량을 감소시키고 g를 1/2로 줄인다.
         6) 받는 수량이 원하는(고정된) 수량과 동일할 때까지 3~5를 반복한다.

    - 일정 단위로 사용된 g 를 세밀하게 조정하면 최적화시키는데 도움이 되지만 시간복잡도 O(log(n))이기 때문에 큰 영향은 없습니다.
    - 다만 시간당 1inch api 요청 건수 제한으로 엔터프라이즈 플랜이 아닌 경우 테스트에 비효율적인 부분이 존재했습니다.
      그래서 다른 방법이 있을까 생각해보았고, 해당 방법은 바로 구현할 수 있는 부분은 아니라서 아래 로직 이후에 글로 표현해두었습니다.
    
    - 받는 토큰의 수량을 고정했을 때 보내는 토큰의 수량을 구하는 두 번째 방법입니다.
      1) 프로토콜 종류마다 AMM 역산 방법을 저장한 라이브러리를 만들어 사용한다.
      2) 보내는 토큰의 양을 임의로 정하여 견적을 받아 우선 최적의 swap 프로토콜을 알아낸다.{ protocols[0][0].part }
      3) 해당 프로토콜의 일련번호(protocols[0][0].part) 값을 통해 역산공식이 저장된 라이브러리에서 보내는 토큰의 수량을 구해 반환한다.
         또는 해당 swap 프로토콜이 역산 함수를 제공하는 경우(ex uniswap v3) 해당 함수를 사용하여 보내는 토큰의 수량을 구한다.
         => 이 방법의 경우 1inch에서 지원하는 모든 swap protocols 의 AMM 에 대한 정리가 선행되어야 하나,
            swap 프로토콜의 수가 제한적이라는 것을 고려하면 가능한 방법이라고 생각합니다.
    
 2. 견적 그대로 swap 을 수행할 수 있는 기능
    - getQuote 또는 getQuoteFor 를 통해 최적의 견적을 구하면, executeSwap 메서드에 견적 데이터 객체를 그대로 인자로 보내어 실행합니다.
    - 먼저 allowance 를 검사하여 approve 가 필요한 경우 토큰 컨트랙트의 approve 함수를 실행하여 1inch 컨트랙트에 allowance 설정을 합니다.
      swap할 토큰의 양과 정확하게 일치하도록 approve 하도록 되어 있습니다. allowance를 max(1inch api default 값)로 설정하는 것은 불필요하다고 생각했습니다.

 3. 기타 추가 사항
    - 최적의 견적을 구하는 경우 입력된 토큰의 종류가 1inch 에서 지원하는 토큰인지 여부를 먼저 확인하도록 했습니다.
    - 개인키를 서버 메모리에 저장하지 않고, 서명되지 않은 raw transaction 을 client 로 보내 서명을 받아 처리하는 경우,
      서명을 받을 원시 트랜잭션 데이터를 생성하여 client 로 보내고,
      client 에서 사용자가 원시 트랜잭션에 서명한 후 서명된 트랜잭션을 서버로 보내면 서버에서 처리하도록 하였습니다.
    - 만약 1inch api 가 permit 을 지원한다면, approve 와 swap 모두 client로부터 permit 데이터를 받아와
      1inch api를 통해 처리하도록 하는 방법이 있을 것입니다.(이 경우 사용자의 gas 비용이 절약된다는 장점이 있으나 permit 지원 여부는 확인이 안됩니다.)
 *
 */

'use strict';

const quote = require("./aggregation/quote");
const swap = require("./aggregation/swap");
const approve = require("./aggregation/approve");

exports = module.exports = quote;

exports.executeSwap = swap.executeSwap;
exports.getSwapTransaction = swap.getSwapTransaction;

exports.getApproveTransaction = approve.getApproveTransaction;