/*!
 1. Swap 의 견적을 얻는 기능 (판매할 수량과 구매할 수량을 각각 고정할 수 있어야 하며, 예상되는 수수료가 포함되어야 한다.)
    - 보내고 받는 두 토큰의 세부 정보와 수량, 최적으로 선택된 swap 프로토콜 정보 및 예상 가스비는
      모두 마지막 res.json() 객체에 담겨 있다.
    - 받는 토큰의 수량을 고정했을 때 역견적을 받는 것은 swap 프로토콜마다 AMM 의 차이가 있고,
      AMM과 수수료 계산 방법에 의해 교환되는 토큰의 수량이 일정 비율로 변하는 것이 아니기 때문에
      모든 swap 프로토콜에 공통적으로 적용할 수 있는 범용적 공식은 존재하지 않는다.
      따라서 보내는 수량을 조절하여 받는 토큰의 갯수가 나올 때까지 api 요청을 반복하여 보내되,
      최소의 요청 횟수로 원하는 값을 얻도록 최적화시키는 방법을 사용하기로 하였다.
      => 이분탐색 알고리즘의 변형
         1) 보내는 수량을 임의로 설정하여 받는 토큰 수량을 얻는다.
         2) 보내는 수량과 받는 수량의 대략적인 비율대로 받는 토큰의 고정수량과 맞는 보내는 토큰 수량을 재설정한다.
         3) 재설정한 토큰으로 견적을 받아 받는 수량을 체크한다.
         4) 받는 수량이 원하는(고정된) 수량보다 적으면 일정 단위 g 만큼 보내는 수량을 증가시키고 g를 1/2로 줄인다.
         5) 받는 수량이 원하는(고정된) 수량보다 많으면 일정 단위 g 만큼 보내는 수량을 감소시키고 g를 1/2로 줄인다.
         6) 받는 수량이 원하는(고정된) 수량과 동일할 때까지 3~5를 반복한다.

    - 일정 단위로 사용된 g 를 세밀하게 조정하면 최적화시키는데 도움이 되지만 시간복잡도 O(log(n))이기 때문에 큰 영향은 없다.
    - 다만 시간당 1inch api 요청 건수 제한으로 엔터프라이즈 플랜이 아닌 경우 테스트에 비효율적인 부분이 존재했다.
      그래서 다른 방법이 있을까 생각해보았고, 해당 방법은 바로 구현할 수 있는 부분은 아니라서 아래 로직 이후에 글로 표현해두었다.
    
    - 받는 토큰의 수량을 고정했을 때 보내는 토큰의 수량을 구하는 두 번째 방법이다.
      1) 프로토콜 종류마다 AMM 역산 방법을 저장한 라이브러리를 만들어 사용한다.
      2) 보내는 토큰의 양을 임의로 정하여 견적을 받아 우선 최적의 swap 프로토콜을 알아낸다.{ protocols[0][0].part }
      3) 해당 프로토콜의 일련번호(protocols[0][0].part) 값을 통해 역산공식이 저장된 라이브러리에서 보내는 토큰의 수량을 구해 반환한다.
         또는 해당 swap 프로토콜이 역산 함수를 제공하는 경우(ex uniswap v3) 해당 함수를 사용하여 보내는 토큰의 수량을 구한다.
         => 이 방법의 경우 1inch에서 지원하는 모든 swap protocols 의 AMM 에 대한 정리가 선행되어야 하나,
            swap 프로토콜의 수가 제한적이라는 것을 고려하면 가능한 방법이다.
    
 2. 견적 그대로 swap 을 수행할 수 있는 기능
    - 견적을 받는 시점과 실제 swap을 실행하는 시점과의 시간차에 의해 slippage 가 발생할 수 있다.
    - 이를 위해 견적을 받을 때 1inch 응답데이터 내의 최소 보장 갯수를 사용자에게 보여주는 방법을 사용한다.
    - getQuote 또는 getQuoteFor 를 통해 최적의 견적을 구하면, executeSwap 메서드에 견적 데이터 객체를 그대로 인자로 보내어 실행한다.
    - 먼저 allowance 를 검사하여 approve 가 필요한 경우 토큰 컨트랙트의 approve 함수를 실행하여 1inch 컨트랙트에 allowance 설정을 한다.
      swap할 토큰의 양과 정확하게 일치하도록 approve 하도록 되어 있다.

 3. 기타 추가 사항
    - 최적의 견적을 구하는 경우 입력된 토큰의 종류가 1inch 에서 지원하는 토큰인지 여부를 먼저 확인하도록 한다.
    - 개인키를 서버 메모리에 저장하지 않고, 서명되지 않은 raw transaction 을 client 로 보내 서명을 받아 처리하는 경우,
      서명을 받을 원시 트랜잭션 데이터를 생성하여 client 로 보내고,
      client 에서 사용자가 원시 트랜잭션에 서명한 후 서명된 트랜잭션을 서버로 보내면 서버에서 처리하도록 한다.
 *
 */

'use strict';

const quote = require("./aggregation/quote");
const swap = require("./aggregation/swap");
const approve = require("./aggregation/approve");

exports = module.exports = quote;

exports.executeSwap = swap.executeSwap;
exports.getSwapTransaction = swap.getSwapTransaction;

exports.getApproveTransaction = approve.getApproveTransaction;